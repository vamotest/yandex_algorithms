
## Index
* [A. Калькулятор](#a-калькулятор)
* [B. Циклы](#b-циклы)

**[⬆ Back to Index](#index)**
## A. Калькулятор

### Task 
[Contest](https://contest.yandex.ru/contest/18357/problems/A/) | [Solution](https://github.com/vamotest/yandex_algorithms/blob/master/12_03_final_tasks/A.%20Reverse%20Polish%20Notation%20Calculator%20-%20Stack.py)
```
Задание связано с обратной польской нотацией. Она используется для парсинга
арифметических выражений. Еще её иногда называют постфиксной нотацией.

В постфиксной нотации операнды расположены перед знаками операций.
```

**Example 1:**
```
3 4 +
будет равно 7, и означает 3 + 4
```

**Example 2:**
```
12 5 /
Так как деление целочисленное, то в результате получим 2.
```

**Example 3:**
```
10 2 4 * -
будет равно 2, и означает 10 - 2 * 4
```
```
Разберём последний пример подробнее:
Знак * стоит сразу после чисел 2 и 4, значит к ним нужно применить операцию, 
которую этот знак обозначает, то есть перемножить эти два числа. 
В результате получим 8.

После этого выражение приобретёт вид:
10 8 -

Операцию «минус» нужно применить к двум идущим перед ней числам, 
то есть 10 и 8. В итоге получаем 2.

Рассмотрим алгоритм более подробно. Для его реализации будем использовать стек.

Для вычисления значения выражения, записанного в обратной польской нотации, 
нужно считывать выражение слева направо и придерживаться следующих шагов:

1) Обработка входного символа:
 * Если на вход подан операнд, он помещается на вершину стека.
 * Если на вход подан знак операции, то эта операция выполняется над требуемым 
 количеством значений из стека, взятых в порядке добавления. 
 Результат выполненной операции помещается на вершину стека.
2) Если входной набор символов обработан не полностью, перейти к шагу 1.
3) После полной обработки входного набора символов результат вычисления 
выражения находится в вершине стека. Если в стеке осталось несколько чисел, 
то надо вывести только верхний элемент.
```
**Замечание про отрицательные числа и деление:**
```
в этой задаче под делением понимается математическое целочисленное деление. 
Это значит, что округление всегда происходит вниз. 
А именно: если a / b = c, то b ⋅ c – это наибольшее число, которое 
не превосходит a и одновременно делится без остатка на b.

Например, -1 / 3 = -1. Будьте осторожны, в C++, Java и go, например, 
деление чисел работает иначе.
```

### Input format
```
В единственной строке дано выражение, записанное в обратной польской нотации. 
Числа и арифметические операции записаны через пробел.

На вход могут подаваться операции: +, -, *, / и числа, 
по модулю не превосходящие 10000.

Гарантируется, что значение промежуточных выражений в тестовых данных 
по модулю не больше 50000.
```

### Output format
```
Выведите единственное число — значение выражения.
```

### Examples

**Example №1**
|   Input   | Output |
|:---------:|:------:|
| 2 1 + 3 * |    9   |

**Example №2**
|     Input     | Output |
|:-------------:|:------:|
| 7 2 + 4 * 2 + |   38   |

**[⬆ Back to Index](#index)**
## B. Циклы

### Task 
[Contest](https://contest.yandex.ru/contest/18357/problems/B/) | [Solution](https://github.com/vamotest/yandex_algorithms/blob/master/12_03_final_tasks/B.%20Detect%20Loop%20in%20a%20Linked%20List.py)
```
В этом спринте вы изучили структуру данных Связный список.
В Связном списке можно, например, хранить дни недели. 
Вторник за понедельником, среда за вторником, и так далее.
```

<div align="center">
  <img src="https://contest.yandex.ru/testsys/statement-image?imageId=7ae7806a99e737a923ff6def9092ce94d357663c4fb95e5cbdc9bf3c858e461d">
</div>

```
Вам предстоит это выяснить!
В качестве второго задания финального проекта нужно написать программу, 
которая определяет, есть ли цикл в связном списке.

На вход функция принимает голову списка, на выходе должна выдать True, 
если в списке содержится цикл, иначе — False.

Размер дополнительной памяти, к которой обращается функция, 
не должен превышать О(1).
```
### Input format
```
В этой задаче вам нужно реализовать только функцию с решением, 
считывать входные данные не нужно.
Функция должна принимать на вход голову связного списка.
```

**Класс, представляющая узел списка выглядит так:**
```python
class Node:  
    def __init__(self, value, next=None):  
        self.value = value  
        self.next = next  
    def __repr__(self):  
        return self.value
```
Ваша функция должна называться `hasCycle`.

### Output format
```
Функция должна возвращать булево значение
```

