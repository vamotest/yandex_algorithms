

## Index
* [A. Кружки](#a-кружки)
* [B. Мониторинг](#b-мониторинг)
* [C. Подстроки](#c-подстроки)
* [D. Соседи](#d-соседи)
* [E. Список дел](#e-список-дел)
* [F. Нелюбимое дело](#f-нелюбимое-дело)
* [G. Заботливая мама](#g-заботливая-мама)
* [H. Все наоборот](#h-все-наоборот)
* [I. Стек - Max](#i-стек---max)
* [J. Стек - MaxEffective](#j-стек---maxeffective)
* [K. Уникальный Стек](#k-уникальный-стек)
* [L. Скобочная последовательность](#l-скобочная-последовательность)
* [M. Очередь](#m-очередь)
* [N. Ограниченная очередь](#n-ограниченная-очередь)
* [O. Шифрование](#o-шифрование)
* [P. Списочная очередь](#p-списочная-очередь)
* [Q. Дек](#q-дек)


**[⬆ Back to Global Index](https://github.com/vamotest/yandex_algorithms#index)**
**[⬆ Back to Index](#index)**
## A. Кружки

### Task 
[Contest](https://contest.yandex.ru/contest/18337/problems/A/) | [Solution](https://github.com/vamotest/yandex_algorithms/blob/master/12_02_basic_data_structures/A.%20Courses.py)
```
Напишите код для решения задачи про поиск кружков, которые посещает хотя бы 
один ученик. Ваше решение должно задействовать O(1) дополнительной памяти 
(то есть помимо памяти, выделенной под массив visited_optional_courses)
```

### Input format
```
1) Записано количество кружков n, целое число, не превосходящее 10000
2) В следующих n строках записаны названия кружков.
```

### Output format
```
Выведите уникальные названия кружков по одному на строке,
в порядке появления во входных данных.
```

### Examples

**Example №1**
|                Input               |               Output               |
|:----------------------------------:|:----------------------------------:|
|                  8                 |         вышивание крестиком        |
|         вышивание крестиком        |     рисование мелками на парте     |
|     рисование мелками на парте     |         настольный керлинг         |
|         настольный керлинг         | кухня африканского племени ужасмай |
|         настольный керлинг         |          тяжелая атлетика          |
| кухня африканского племени ужасмай |           таракановедение          |
|          тяжелая атлетика          |                                    |
|           таракановедение          |                                    |
|           таракановедение          |                                    |


**[⬆ Back to Global Index](https://github.com/vamotest/yandex_algorithms#index)**
**[⬆ Back to Index](#index)**
## B. Мониторинг

### Task 
[Contest](https://contest.yandex.ru/contest/18337/problems/B/) | [Solution](https://github.com/vamotest/yandex_algorithms/blob/master/12_02_basic_data_structures/B.%20Monitoring.py)
```
Алла получила задание, связанное с мониторингом работы различных серверов. 
Требуется понять, сколько времени обрабатываются определённые запросы 
на конкретных серверах. Эту информацию нужно хранить в матрице, 
где номер столбца соответствуют идентификатору запроса, 
а номер строки — идентификатору сервера. 

Алла перепутала строки и столбцы местами. С каждым бывает. 
Помогите ей исправить баг.

Есть матрица размера m × n. Нужно написать функцию, которая её транспонирует.
Транспонированная матрица получается из исходной заменой строк на столбцы.

Например, для матрицы 
А = [
        [1, 2, 3],
        [0, 2, 6],
        [7, 4, 1],
        [2, 7, 0],
]


транспонированной будет следующая матрица:
A = [
        [1, 0, 7, 2],
        [2, 2, 4, 7],
        [3, 6, 1, 0]
]
```

### Input format
```
1) Число n — количество строк матрицы.
2) m — число столбцов, m и n не превосходят 1000. 
3) В следующих n строках задана матрица. 
Числа в матрице не превосходят по модулю 1000.
```

### Output format
```
Напечатайте транспонированную матрицу в том же формате, который задан
во входных данных. Каждая строка матрицы печатается на отдельной строке,
элементы разделяются пробелами.
```

### Examples

**Example №1**
| Input |  Output |
|:-----:|:-------:|
|   4   | 1 0 7 2 |
|   3   | 2 2 4 7 |
| 1 2 3 | 3 6 1 0 |
| 0 2 6 |         |
| 7 4 1 |         |
| 2 7 0 |         |

**Example №2**
|     Input     |          Output         |
|:-------------:|:-----------------------:|
|       9       |  -7 5 3 9 2 -7 -3 1 -1  |
|       5       |  -1 -1 1 0 4 10 10 6 9  |
| -7 -1 0 -4 -9 |   0 2 -8 8 5 0 -7 -7 9  |
|   5 -1 2 2 9  | -4 2 -1 -8 2 -4 10 -5 1 |
|  3 1 -8 -1 -7 |  -9 9 -7 -1 8 -8 3 9 9  |
|  9 0 8 -8 -1  |                         |
|   2 4 5 2 8   |                         |
| -7 10 0 -4 -8 |                         |
| -3 10 -7 10 3 |                         |
|  1 6 -7 -5 9  |                         |
|   -1 9 9 1 9  |                         |


**[⬆ Back to Global Index](https://github.com/vamotest/yandex_algorithms#index)**
**[⬆ Back to Index](#index)**
## C. Подстроки

### Task 
[Contest](https://contest.yandex.ru/contest/18337/problems/C/) | [Solution](https://github.com/vamotest/yandex_algorithms/blob/master/12_02_basic_data_structures/C.%20Substrings.py)
```
На вход подается строка. Нужно определить длину наибольшей подстроки,
которая не содержит повторяющиеся символы.
```

### Input format
```
Одна строка, состоящая из латинских букв. Длина строки не превосходит 10000.
```

### Output format
```
Одно число - ответ на задачу.
```

### Examples

**Example №1**
|   Input  | Output |
|:--------:|:------:|
| abcabcbb |    3   |

**Example №2**
| Input | Output |
|:-----:|:------:|
| bbbbb |    1   |


**[⬆ Back to Global Index](https://github.com/vamotest/yandex_algorithms#index)**
**[⬆ Back to Index](#index)**
## D. Соседи

### Task 
[Contest](https://contest.yandex.ru/contest/18337/problems/D/) | [Solution](https://github.com/vamotest/yandex_algorithms/blob/master/12_02_basic_data_structures/D.%20Neighbors.py)
```
Дана матрица. Нужно написать функцию, которая для элемента возвращает всех
его соседей. Соседним считается элемент, находящийся от текущего
на одну ячейку влево, вправо, вверх или вниз. 

Диагональные элементы соседними не считаются.

Например, в матрице
A = [
        [1, 2, 3],
        [0, 2 ,6],
        [7, 4, 1],
        [2, 7, 0]
]

соседними элементами для (0, 0) будут 2 и 0 А для (2, 1) — 1, 2, 7, 7.
```

### Input format
```
1) n - количество строк матрицы. 
2) m - количество столбцов. Числа m и n не превосходят 1000. 
3) В следующих n строках задана матрица. Элементы матрицы - целые числа,
по модулю не превосходящие 1000. В последних двух строках записаны координаты
элемента (индексация начинается с нуля), соседей которого нужно найти.
```

### Output format
```
Напечатайте нужные числа в возрастающем порядке через пробел.
```

### Examples

**Example №1**
| Input | Output |
|:-----:|:------:|
|   4   |    7   |
|   3   |    7   |
| 1 2 3 |        |
| 0 2 6 |        |
| 7 4 1 |        |
| 2 7 0 |        |
|   3   |        |
|   0   |        |

**Example №2**
| Input | Output |
|:-----:|:------:|
|   4   |    0   |
|   3   |    2   |
| 1 2 3 |        |
| 0 2 6 |        |
| 7 4 1 |        |
| 2 7 0 |        |
|   0   |        |
|   0   |        |


**[⬆ Back to Global Index](https://github.com/vamotest/yandex_algorithms#index)**
**[⬆ Back to Index](#index)**
## E. Список дел

### Task 
[Contest](https://contest.yandex.ru/contest/18337/problems/E/) | [Solution](https://github.com/vamotest/yandex_algorithms/blob/master/12_02_basic_data_structures/E.%20List%20of%20cases.py)
```
Васе нужно распечатать свой список дел на сегодня. 
Помогите ему: напишите функцию, которая печатает все его дела. 
Известно, что дел у Васи не больше 5000.

Внимание: в этой задаче не нужно считывать входные данные. Нужно написать
только функцию, которая принимает на вход голову списка и печатает его элементы.
Ниже дано описание структуры, которая задаёт узел списка.

Внимание! Решение надо отправлять только в виде файла с расширением, которое 
соответствует вашему языку. Иначе даже корректно написанное решение
не пройдет тесты.
```

### Input format
```
В качестве ответа сдайте только код функции, которая печатает элементы списка.
Длина списка не превосходит 5000 элементов. Список не бывает пустым.
```

### Output format
```
Функция должна напечатать элементы списка по одному в строке.

Python:
Если вы пишете на Python, функция должна принимать на вход вершину node
и иметь сигнатуру

solution(node) -> None
Узел списка описывается следующим классом:
```
```python
class Node:  
    def __init__(self, value, next_item=None):  
        self.value = value  
        self.next_item = next_item
```

**[⬆ Back to Index](#index)**
## F. Нелюбимое дело

### Task 
[Contest](https://contest.yandex.ru/contest/18337/problems/F/) | [Solution](https://github.com/vamotest/yandex_algorithms/blob/master/12_02_basic_data_structures/F.%20Least%20favorite%20thing.py)
```
Вася размышляет, что бы такое из списка не делать. 
Но, кажется, все пункты очень важные! Вася решает загадать число и удалить дело,
которое идёт под этим номером. Список дел представлен в виде односвязного списка.

Напишите функцию solution, которая принимает на вход голову списка и номер
удаляемого дела и возвращает голову обновлённого списка.

Внимание: в этой задаче не нужно считывать входные данные. 
Нужно написать только функцию, которая принимает на вход голову списка и
номер удаляемого элемента и возвращает голову обновленного списка. 

Ниже дано описание структуры, которая задаёт вершину списка.
```

### Input format
```
Функция принимает голову списка и индекс элемента, который надо удалить 
(нумерация с нуля). Список содержит не более 5000 элементов.
Список не бывает пустым.

Узел списка описывается следующим классом:
```
```python
class Node:  
    def __init__(self, value, next_item=None):  
        self.value = value  
        self.next_item = next_item
```
```
Сигнатура функции: solution(node, idx) -> Node
```
### Output format
```
Верните голову списка, в котором удален нужный элемент.
```


**[⬆ Back to Global Index](https://github.com/vamotest/yandex_algorithms#index)**
**[⬆ Back to Index](#index)**
## G. Заботливая мама

### Task 
[Contest](https://contest.yandex.ru/contest/18337/problems/G/) | [Solution](https://github.com/vamotest/yandex_algorithms/blob/master/12_02_basic_data_structures/G.%20Caring%20mother.py)
```
Мама Васи хочет знать, что сын планирует делать и когда. 
Помогите ей: напишите функцию solution, определяющую индекс
первого вхождения передаваемого ей на вход значения в связном списке, 
если значение присутствует.

Внимание: в этой задаче не нужно считывать входные данные.
Нужно написать только функцию, которая принимает на вход голову списка
и искомый элемент, а возвращает целое число — индекс найденного элемента или -1.
Ниже дано описание структуры, которая задаёт вершину списка.
```

### Input format
```
Функция на вход принимает голову односвязного списка и элемент, 
который нужно найти. Длина списка не превосходит 10000 элементов.
Список не бывает пустым.

Узел списка описывается следующим классом:
```

```python
class Node:  
    def __init__(self, value, next_item=None):  
        self.value = value  
        self.next_item = next_item
```
```
Сигнатура функции: solution(node, elem) -> int.
```

### Output format
```
Функция возвращает индекс первого вхождения искомого элемента в список
(индексация начинается с нуля). Если элемент не найден, нужно вернуть -1.
```


**[⬆ Back to Global Index](https://github.com/vamotest/yandex_algorithms#index)**
**[⬆ Back to Index](#index)**
## H. Все наоборот

### Task 
[Contest](https://contest.yandex.ru/contest/18337/problems/H/) | [Solution](https://github.com/vamotest/yandex_algorithms/blob/master/12_02_basic_data_structures/H.%20The%20opposite%20is%20true.py)
```
Вася решил запутать маму —– делать дела в обратном порядке.
Список его дел теперь хранится в двусвязном списке.
Напишите функцию, которая вернёт список в обратном порядке.

Внимание: в этой задаче не нужно считывать входные данные. 
Нужно написать только функцию, которая принимает на вход голову 
двусвязного списка и возвращает голову перевернутого списка. 
Ниже дано описание структуры, которая задаёт вершину списка.

Если вы пишете на Python, функция должна называться solution
и принимать на вход вершину node.
```

### Input format
```
Узел списка описывается следующим классом:
```
```python
class DoubleConnectedNode:  
    def __init__(self, value, next=None, prev=None):  
        self.value = value  
        self.next = next  
        self.prev = prev
```
```
Сигнатура функции:
solution(node: DoubleConnectedNode) -> DoubleConnectedNode
```


### Output format
```
Функция должна вернуть голову развернутого списка.
```


**[⬆ Back to Global Index](https://github.com/vamotest/yandex_algorithms#index)**
**[⬆ Back to Index](#index)**
## I. Стек - Max

### Task 
[Contest](https://contest.yandex.ru/contest/18337/problems/I/) | [Solution](https://github.com/vamotest/yandex_algorithms/blob/master/12_02_basic_data_structures/I.%20Stack%20Max.py)
```
Нужно реализовать класс StackMax, который поддерживает операцию определения
максимума среди всех элементов в стеке. Класс должен поддерживать операции 
push, pop и get_max.

Стек может содержать только данные типов, поддерживающих операцию сравнения. 
Иначе операция поиска максимума будет некорректной.
```

### Input format
```
1) одно число n - количество команд. n не превосходит 1000. 
В следующих n строках идут команды. Команды могут быть следующих видов:

* push x - добавить число x в стек
* pop - удалить число с вершины стека
* get_max - напечатать максимальное число в стеке

Если стек пуст при вызове команды get_max нужно напечатать None, 
для команды pop - error.
```

### Output format
```
Для каждой команды get_max напечатайте результат её выполнения. 
Если стек пустой, для команды get_max напечатайте None. 
Если происходит удаление из пустого стека - напечатайте error.
```

### Examples

**Example №1**
|  Input  | Output |
|:-------:|:------:|
|    8    |  None  |
| get_max |   -2   |
|  push 7 |   -2   |
|   pop   |        |
| push -2 |        |
| push -1 |        |
| get_max |        |
| get_max |        |

**Example №2**
|  Input  | Output |
|:-------:|:------:|
|    7    |  None  |
| get_max |  error |
|   pop   |  error |
|   pop   |  error |
|   pop   |   10   |
| push 10 |        |
| get_max |        |
| push -9 |        |


**[⬆ Back to Global Index](https://github.com/vamotest/yandex_algorithms#index)**
**[⬆ Back to Index](#index)**
## J. Стек - MaxEffective

### Task 
[Contest](https://contest.yandex.ru/contest/18337/problems/J/) | [Solution](https://github.com/vamotest/yandex_algorithms/blob/master/12_02_basic_data_structures/J.%20Stack%20-%20MaxEffective.py)
```
Реализуйте класс StackMaxEffective, поддерживающий операцию определения
максимума среди элементов в стеке. Сложность операции должна быть O(1). 
Для пустого стека операция должна возвращать None. 
При этом push и pop также должны выполняться за константное время.
```

### Input format
```
1) Одно число - количество команд, оно не превосходит 100000. 
Далее идут команды по одной в строке. Команды могут быть следующих видов:

* push x — добавить число x в стек
* pop — удалить число с вершины стека
* get_max — напечатать максимальное число в стеке

Если стек пуст, при вызове команды get_max нужно напечатать «None», 
для команды pop — «error».
```

### Output format
```
Для каждой команды get_max напечатайте результат её выполнения.
Если стек пустой, для команды get_max напечатайте «None».
Если происходит удаление из пустого стека — напечатайте «error».
```

### Examples

**Example №1**
|  Input  | Output |
|:-------:|:------:|
|    10   |  None  |
|   pop   |  error |
|   pop   |  error |
|  push 4 |  error |
| push -5 |   10   |
|  push 7 |        |
|   pop   |        |
|   pop   |        |
| get_max |        |
|   pop   |        |
| get_max |        |

**Example №2**
|  Input  | Output |
|:-------:|:------:|
|    10   |  None  |
| get_max |  error |
| push -6 |  None  |
|   pop   |    2   |
|   pop   |        |
| get_max |        |
|  push 2 |        |
| get_max |        |
|   pop   |        |
| push -2 |        |
| push -6 |        |


**[⬆ Back to Global Index](https://github.com/vamotest/yandex_algorithms#index)**
**[⬆ Back to Index](#index)**
## K. Уникальный Стек

### Task 
[Contest](https://contest.yandex.ru/contest/18337/problems/K/) | [Solution](https://github.com/vamotest/yandex_algorithms/blob/master/12_02_basic_data_structures/K.%20Unique%20Stack.py)
```
Реализуйте класс StackSet, который хранит только уникальные элементы.
При этом операция добавления элемента в стек должна выполняться за O(1).
```

### Input format
```
1) Одно число - количество команд. Далее идут команды по одной на строке.
Команды могут быть следующих видов:

* push x - добавить число x в стек
* pop - удалить число с вершины стека
* peek - напечатать число с вершины стека (без удаления)
* size - узнать размер стека

Если стек пуст при вызове команд pop и peek нужно вывести на печать error.
```

### Output format
```
Для каждой команды size напечатайте результат её выполнения.
Если происходит удаление из пустого стека - напечатайте error.
```

### Examples

**Example №1**
|  Input | Output |
|:------:|:------:|
|    8   |    2   |
| push 1 |    2   |
| push 2 |    1   |
|  size  |        |
| push 2 |        |
|  size  |        |
|   pop  |        |
| push 1 |        |
|  size  |        |

**Example №2**
|  Input | Output |
|:------:|:------:|
|   10   |    1   |
| push 1 |    2   |
|   pop  |        |
| push 2 |        |
|  size  |        |
| push 1 |        |
| push 2 |        |
|   pop  |        |
| push 2 |        |
|  peek  |        |
|   pop  |        |


**[⬆ Back to Global Index](https://github.com/vamotest/yandex_algorithms#index)**
**[⬆ Back to Index](#index)**
## L. Скобочная последовательность

### Task 
[Contest](https://contest.yandex.ru/contest/18337/problems/L/) | [Solution](https://github.com/vamotest/yandex_algorithms/blob/master/12_02_basic_data_structures/L.%20Bracket%20sequence.py)
```
Вот какую задачу Тимофей предложил на собеседовании одному из кандидатов. 
Если вы с ней ещё не сталкивались, то наверняка столкнётесь –— она довольно
популярная.

Дана скобочная последовательность. Нужно определить, правильная ли она.

Будем придерживаться такого определения:
* пустая строка —– правильная скобочная последовательность;
* правильная скобочная последовательность, взятая в скобки одного типа,
 –— правильная скобочная последовательность;
* правильная скобочная последовательность с приписанной слева или 
справа правильной скобочной последовательностью —– тоже правильная.

На вход подается последовательность из скобок трёх видов: [], (), {}.
Напишите функцию is_correct_bracket_seq, которая принимает 
на вход скобочную последовательность и возвращает True, 
если последовательность правильная, а иначе False.
```

### Input format
```
На вход подаётся одна строка, содержащая скобочную последовательность.
Скобки записаны подряд, без пробелов.
```

### Output format
```
Выведите «True» или «False».
```

### Examples

**Example №1**
|  Input | Output |
|:------:|:------:|
| {[()]} |  True  |

**Example №2**
| Input | Output |
|:-----:|:------:|
|   ()  |  True  |


**[⬆ Back to Global Index](https://github.com/vamotest/yandex_algorithms#index)**
**[⬆ Back to Index](#index)**
## M. Очередь

### Task 
[Contest](https://contest.yandex.ru/contest/18337/problems/M/) | [Solution](https://github.com/vamotest/yandex_algorithms/blob/master/12_02_basic_data_structures/M.%20Queue.py)
```
Перед Тимофеем стоит задача написать несколько реализаций собственной очереди,
так как доступные на рынке варианты для проекта не подходят.

Требования к первой вот такие: класс должен называться MyQueue(), 
поддерживать операции добавления, удаления, получения элемента, 
определение текущего размера, и метод, показывающий, пуста ли очередь или нет.
Реализована структура данных должна быть на основе массива.
```

### Input format
```
Формат ввода
В первой строке записано одно число - количество команд, 
оно не превосходит 5000. Далее идут команды по одной в строке. 

Команды могут быть следующих видов:
* push x - добавить число x в очередь
* pop - удалить число из очереди и напечатать его
* peek - напечатать первое число в очереди
* size - вернуть размер очереди
```

### Output format
```
Для каждой команды size, peek и pop напечатайте результат её выполнения.
Если очередь пуста, для команды peek напечатайте None. 
Если происходит удаление из пустой очереди — напечатайте None.
```

### Examples

**Example №1**
|  Input  | Output |
|:-------:|:------:|
|    10   |    0   |
|   size  |    0   |
|  push 0 |    1   |
|   pop   |    2   |
|  push 2 |        |
|   size  |        |
| push -2 |        |
|   pop   |        |
| push -8 |        |
|  push 4 |        |
|  push 6 |        |

**Example №2**
|  Input  | Output |
|:-------:|:------:|
|    10   |    4   |
|  push 4 |    1   |
|   pop   |    2   |
| push -1 |    3   |
|   size  |   -1   |
|  push 0 |    0   |
|   size  |        |
| push -4 |        |
|   size  |        |
|   pop   |        |
|   peek  |        |


**[⬆ Back to Global Index](https://github.com/vamotest/yandex_algorithms#index)**
**[⬆ Back to Index](#index)**
## N. Ограниченная очередь

### Task 
[Contest](https://contest.yandex.ru/contest/18337/problems/N/) | [Solution](https://github.com/vamotest/yandex_algorithms/blob/master/12_02_basic_data_structures/N.%20Limited%20queue.py)
```
Далее Тимофею нужно написать класс MyQueueSized, который принимает
параметр max_size, означающий максимально допустимое
количество элементов в очереди.
```

### Input format
```
1) Одно число — количество команд, оно не превосходит 5000.
2) Задан максимально допустимый размер очереди, он не превосходит 5000.

Далее идут команды по одной на строке. Команды могут быть следующих видов:
* push x — добавить число x в очередь
* pop — удалить число из очереди и вывести на печать
* peek — напечатать первое число в очереди
* size — вернуть размер очереди

При превышении допустимого размера очереди нужно вывести «error». 
При вызове операции pop или peek для пустой очереди нужно вывести «None».
```

### Output format
```
Напечатайте результаты выполнения нужных команд, по одному на строке.
```

### Examples

**Example №1**
|  Input | Output |
|:------:|:------:|
|    8   |  None  |
|    2   |    5   |
|  peek  |    2   |
| push 5 |    2   |
| push 2 |  error |
|  peek  |    2   |
|  size  |        |
|  size  |        |
| push 1 |        |
|  size  |        |

**Example №2**
|  Input | Output |
|:------:|:------:|
|   10   |    1   |
|    1   |  error |
| push 1 |    1   |
|  size  |  error |
| push 3 |    1   |
|  size  |    1   |
| push 1 |  error |
|   pop  |        |
| push 1 |        |
|   pop  |        |
| push 3 |        |
| push 3 |        |


**[⬆ Back to Global Index](https://github.com/vamotest/yandex_algorithms#index)**
**[⬆ Back to Index](#index)**
## O. Шифрование

### Task 
[Contest](https://contest.yandex.ru/contest/18337/problems/O/) | [Solution](https://github.com/vamotest/yandex_algorithms/blob/master/12_02_basic_data_structures/O.%20Encryption.py)
```
Алла реализовывала алгоритм шифрования и что-то напутала. 
В итоге после расшифровки буквы в словах получились в произвольном порядке. 
Помогите Алле разобраться с проблемой. Напишите функцию, принимающую
на вход строку и шаблон и определяющую, сколько анаграмм шаблона будет в строке.

Напомним, что два слова — анаграммы, если одно из них можно получить из другого,
переставив буквы. Например, слова «кот» и «ток».
```

### Input format
```
1) Задана строка, в которой будет производиться поиск. 
2) Шаблон. Длина обеих строк не превосходит 1000 и длина шаблона не может
быть больше длины строки для поиска.
```

### Output format
```
Одно число - ответ на задачу.
```

### Examples

**Example №1**
| Input | Output |
|:-----:|:------:|
|  cba  |    1   |
|  abc  |        |

**Example №2**
|    Input   | Output |
|:----------:|:------:|
| abcsdfacba |    3   |
|     abc    |        |


**[⬆ Back to Global Index](https://github.com/vamotest/yandex_algorithms#index)**
**[⬆ Back to Index](#index)**
## P. Списочная очередь

### Task 
[Contest](https://contest.yandex.ru/contest/18337/problems/P/)
```
Любимый вариант очереди Тимофея — очередь, написанная с использованием
связного списка. Помогите ему с реализацией. Очередь должна поддерживать
выполнение трёх команд:

* get — вывести элемент в голове очереди и удалить его. Если очередь пуста, то вывести «error».
* put x — добавить число x в очередь
* size — вывести текущий размер очереди
```

### Input format
```
В первой строке записано количество команд n — целое число, 
не превосходящее 1000. В каждой из следующих n строк записаны 
команды по одной строке.
```

### Output format
```
Выведите ответ на каждый запрос по одному в строке.
```

### Examples

**Example №1**
|  Input  | Output |
|:-------:|:------:|
|    10   |   -34  |
| put -34 |    1   |
| put -23 |   -23  |
|   get   |    0   |
|   size  |  error |
|   get   |    1   |
|   size  |        |
|   get   |        |
|   get   |        |
|  put 80 |        |
|   size  |        |

**Example №2**
|  Input  | Output |
|:-------:|:------:|
|    6    |    2   |
| put -66 |    2   |
|  put 98 |   -66  |
|   size  |   98   |
|   size  |        |
|   get   |        |
|   get   |        |

**Example №3**

|  Input | Output |
|:------:|:------:|
|    9   |  error |
|   get  |    0   |
|  size  |   74   |
| put 74 |    0   |
|   get  |    1   |
|  size  |    1   |
| put 90 |    1   |
|  size  |        |
|  size  |        |
|  size  |        |


**[⬆ Back to Global Index](https://github.com/vamotest/yandex_algorithms#index)**
**[⬆ Back to Index](#index)**
## Q. Дек

### Task 
[Contest](https://contest.yandex.ru/contest/18337/problems/Q/) | [Solution]()
```
Гоша реализовал структуру данных Дек, максимальный размер которого определяется
заданным числом. Методы push_back, push_front, pop_back, pop_front 
работали корректно. Но, если в деке было много элементов, программа работала 
очень долго. Дело в том, что не все операции выполнялись за O(1).

Помогите Гоше! Напишите эффективную реализацию.
Внимание: при реализации нельзя использовать связный список.
```

### Input format
```
В первой строке записано количество команд n — целое число, не превосходящее 5000. Во второй строке записано число m — максимальный размер дека. Он не превосходит 1000. В следующих n строках записана одна из команд:

* push_back value – добавить элемент в конец дека. Если в деке уже находится 
максимальное число элементов, вывести «error».
* push_front value – добавить элемент в начало дека. Если в деке уже находится 
максимальное число элементов, вывести «error».
* pop_front – вывести первый элемент дека и удалить его. Если дек был пуст, 
то вывести «error».
* pop_back – вывести последний элемент дека и удалить его. Если дек был пуст, 
то вывести «error».

value — целое число, по модулю не превосходящее 1000.
```

### Output format
```
Выведите результат выполнения каждой команды на отдельной строке. 
Для успешных запросов push_back и push_front ничего выводить не надо.
```

### Examples

**Example №1**
|      Input      | Output |
|:---------------:|:------:|
|        4        |   861  |
|        4        |  -819  |
|  push_front 861 |        |
| push_front -819 |        |
|     pop_back    |        |
|     pop_back    |        |

**Example №2**
|      Input      | Output |
|:---------------:|:------:|
|        7        |  -855  |
|        10       |   720  |
| push_front -855 |   844  |
|  push_front 720 |        |
|     pop_back    |        |
|     pop_back    |        |
|  push_back 844  |        |
|     pop_back    |        |
|  push_back 823  |        |

**Example №3**
|      Input      | Output |
|:---------------:|:------:|
|        6        |   20   |
|        6        |   102  |
| push_front -201 |        |
|  push_back 959  |        |
|  push_back 102  |        |
|  push_front 20  |        |
|    pop_front    |        |
|     pop_back    |        |
